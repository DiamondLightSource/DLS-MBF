#!/usr/bin/env python

from driver import SYSTEM, CONTROL, DSP0, DSP1, ADC_SPI, DDR0_NAME
import numpy

CAPTURE_COUNT = 1024*1024

# Configure the ADC FIR for passthrough mode
def reset_dsp(dsp):
    dsp.MISC.STROBE.WRITE = 1
    dsp.ADC.TAPS = 0x7FFFFFFF
    for i in range(7):
        dsp.ADC.TAPS = 0

def set_idelay(delay):
    SYSTEM.ADC_IDELAY._write_fields_wo(VALUE = delay, WRITE = 1)

def capture(count):
    # Each counted capture corresponds to 8 captured bytes
    bytes = 8 * count
    CONTROL.MEM.COUNT = count + 32
    CONTROL.MEM.COMMAND._write_fields_wo(START = 1, STOP = 1)
    while SYSTEM.STATUS.DRAM0_ENABLE:
        pass
    with open(DDR0_NAME) as ddr0:
        buf = numpy.frombuffer(ddr0.read(bytes), dtype = numpy.uint16)
    return buf.reshape((-1, 2, 2))

def show(a):
    return '%04x %04x %04x %04x' % (a[0, 0], a[0, 1], a[1, 0], a[1, 1])

def assess(c):
    v = c.std(0).mean()
    return v == 0 and (numpy.diff(c.mean(0)) == 0).all()

# Configure checkerboard ADC capture
idelay = SYSTEM.ADC_IDELAY.VALUE
ADC_SPI[0x550] = 4

# Ensure we're in ADC passthrough mode by setting ADC FIR to straighthrough
reset_dsp(DSP0)
reset_dsp(DSP1)


# The IDELAY step size is 1/(32 * 2 * f_REF) with f_REF = 200 MHz, which comes
# to 78.125 ps, so 25 steps covers the 2ns input clock
N = 26
good = numpy.zeros(N, dtype = bool)
for delay in range(N):
    set_idelay(delay)
    c = capture(CAPTURE_COUNT)
    m = c.std(0).mean()
    good[delay] = assess(c)
    print '%02x' % delay, m, show(c.mean(0)), good[delay]

# Restore previous state
ADC_SPI[0x550] = 0
set_idelay(idelay)
