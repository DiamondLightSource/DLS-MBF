#!/usr/bin/env python

import argparse
import math

from lmbf.driver.driver import SYSTEM, CONTROL, DSP0, DSP1, ADC_SPI, DDR0_NAME
import numpy


parser = argparse.ArgumentParser(description = 'Scan for best IDELAY setting')
parser.add_argument('-f', dest = 'f_rf', default = 500, type = float)
parser.add_argument('-s', dest = 'idelay', type = lambda s: int(s, 0))
parser.add_argument(
    '-n', dest = 'capture_count', default = 1024 * 1024, type = int)
args = parser.parse_args()

# The IDELAY step size is 1/(32 * 2 * f_REF) with f_REF = 200 MHz, which comes
# to 78.125 ps, so 25 steps covers the 2ns input clock
idelay_step = 78.125
N = int(math.ceil(1e6 / args.f_rf / idelay_step))
assert N < 32, 'RF frequency too low'


def set_idelay(delay):
    SYSTEM.ADC_IDELAY._write_fields_wo(VALUE = delay, WRITE = 1)

def capture(count):
    # Each counted capture corresponds to 8 captured bytes
    bytes = 8 * count
    CONTROL.MEM.COUNT = count + 32
    CONTROL.MEM.COMMAND._write_fields_wo(START = 1, STOP = 1)
    while CONTROL.MEM.STATUS.ENABLE:
        pass
    with open(DDR0_NAME) as ddr0:
        buf = numpy.frombuffer(ddr0.read(bytes), dtype = numpy.uint16)
    return buf.reshape((-1, 2, 2))

def show(a):
    return '%04x %04x %04x %04x' % (a[0, 0], a[0, 1], a[1, 0], a[1, 1])

def assess(c):
    v = c.std(0).mean()
    return v == 0 and (numpy.diff(c.mean(0)) == 0).all()


# Configure checkerboard ADC capture
if args.idelay is None:
    idelay = SYSTEM.ADC_IDELAY.VALUE
else:
    idelay = args.idelay
ADC_SPI[0x550] = 4

# Configure DRAM capture using unprocessed ADC channels
DSP0.ADC.CONFIG.DRAM_SOURCE = 0
DSP1.ADC.CONFIG.DRAM_SOURCE = 0
CONTROL.MEM.CONFIG.MUX_SELECT = 0




good = numpy.zeros(N, dtype = bool)
for delay in range(N):
    set_idelay(delay)
    c = capture(args.capture_count)
    m = c.std(0).mean()
    good[delay] = assess(c)
    print '%02x' % delay, show(c.mean(0)), m == 0.0, good[delay]

# Restore previous state
ADC_SPI[0x550] = 0
set_idelay(idelay)
