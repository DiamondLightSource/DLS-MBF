#!/usr/bin/env python

# Configuring the LMK04828B
#
# We run the clock controller in Nested 0-delay Dual Loop mode: this means that
# the regenerated RF output clock is used as feedback to the input:
#
#   f_RF -- /R1 --|
#                 | PD1 >-- VCXO -- /R2 --|
#       +-- /N1 --|                       | PD2 >-- VCO --+-- /D --+-- f_RF
#       |                       +-- /N2 --|               |        |
#       |                       +-------------------------+        |
#       +----------------------------------------------------------+
#
# The governing equations of the system above (put f_in = f_RF, f_out =
# regenerated f_RF, f1 = VCXO frequency, f2 = VCO frequency, d1 = first
# Phase Detector frequency, d2 = second Phase Detector frequency) are:
#
#   (1)     d1 = f_in / R1 = f_out / N1
#   (2)     d2 = f1 / R2 = f2 / N2
#   (3)     f_out = f2 / D
#
# Our operating constraints are quite tight:
#
#   (4)     f_in = f_out = f_RF
#   (5)     f1 = 100 MHz +-10 kHz (10^-4)
#   (6)     f2 = 2370 to 2630 MHz or 2920 to 3080 MHz (VCO0 or VCO1)
#   (7)     d1 < 40 MHz, d2 < 500 MHz but otherwise as large as possible.
#
# From (1, 4) we get R1 = N1 and from (7) we get N1, R1 >= f_RF / 40 MHz, and
# (3, 6) constrains the choice of VCO and defines D.  For our two target
# frequencies of interest we have:
#
#   f_RF            500 MHz         352 MHz
#   N1 = R1         13              9
#   VCO0 D          5               7
#   VCO1 D          6               -
#
# From the remaining constraints and equations we have
#
#       N2 / R2 = D * f_RF / f_1
#
# We want R2 to be as small as possible, as this determines d2 = f1/R2, and
# there is also the constraint that N2 must be divisible by a small prime
# (2, 3, 5, or 7).


import sys
import math
import itertools


# Fixed frequency crystal oscillator, centre frequency 100 MHz +- 10kHz
F1 = 100.0
F1 = 200.0
FRACTION = 1e-4

# Choice of internal VCOs
VCO0 = (0, 'VCO0', (2370., 2630.))      # 2.4 to 2.6 GHz
VCO1 = (1, 'VCO1', (2920., 3080.))      # 2.9 to 3.1 GHz


# Returns small prime factor of n or 0 if not possible
def factor(n):
    pp = [2, 3, 5, 7]
    for p in pp:
        if n % p == 0:
            return p
    return 0


# Check that N is divisible by a small prime
def test_div(n):
    return factor(n) > 0


# If f is accessible from vco returns list of appropriate divisors
def check_nco(vco, f):
    l = int(math.ceil(vco[0] / f))
    r = int(math.floor(vco[1] / f))
    if l > r:
        # Nope
        return []
    else:
        # In principle we could be spoilt for choice.  Doesn't happen with 500
        # or 352 MHz, but can happen with some smaller frequencies.
        return range(l, r + 1)


# This function returns a list of possible matches and their errors.
def find_matches(f_RF, D, threshold = FRACTION, f1 = F1):
    K = D * f_RF / f1

    max_error = 1
    for r2 in xrange(1, int(65535 / K)):
        n2 = int(round(r2 * K))
        if test_div(n2):
            error = (r2 * K / n2 - 1) / FRACTION

            # Only report improvements on the error bound
            if abs(error) < max_error:
                max_error = abs(error)
                yield ((r2, n2), error)

            # Once we get to 10% offset there's no point in looking further
            if max_error < 0.1:
                break


# Prints a single match generated by find_matches
def print_match(f_rf, nco_ix, d, r2, n2, e):
    n1 = math.ceil(f_rf / 40)
    p2 = factor(n2)

    # Print summary of frequency fit
    print '(R2 = %3d, N2 = %4d = %d * %4d), offset = %+5.1f%%  |' % (
        r2, n2, p2, n2 / p2, 100 * e),

    # Print settings for clock_mode line.  This is a sequence of six
    # numbers that can be added to mbf.driver.setup_pll.PLL_ratios or can be
    # assigned to clock_mode.
    print '%d %d %d %d %d %d' % (n1, nco_ix, d, p2, n2 / p2, r2)


f_rf = float(sys.argv[1])

for nco_ix, name, vco in [VCO0, VCO1]:
    for d in check_nco(vco, f_rf):
        print '%s D = %d' % (name, d)
        for (r2, n2), e in find_matches(f_rf, d):
            print_match(f_rf, nco_ix, d, r2, n2, e)
