#!/usr/bin/env python

# Fill DDR0 with pattern, read out and check.

import sys
import numpy
import time

from driver import regs, DDR0_NAME

MEM_GEN_W0 = 0
MEM_GEN_S0 = 1
MEM_GEN_W1 = 0xA5A5A5A5
MEM_GEN_S1 = 0

class Ticker:
    pattern = '|/-\\'
    def __init__(self):
        self.tick = 0
    def step(self):
        sys.stdout.write('%s\r' % self.pattern[self.tick])
        sys.stdout.flush()
        self.tick += 1
        if self.tick >= len(self.pattern):
            self.tick = 0

def check_pattern(start, step, result):
    N = len(result)
    pattern = start + step * numpy.arange(len(result), dtype = numpy.uint32)
    print numpy.flatnonzero(pattern != result)


# Set up memory pattern and start write
regs.mem_gen[0] = MEM_GEN_W0
regs.mem_gen[1] = MEM_GEN_W1
regs.mem_gen[2] = MEM_GEN_S0
regs.mem_gen[3] = MEM_GEN_S1
assert not regs.mem_gen[7]
# Small bug in memory generator, need to subtract 1 from target count!
regs.mem_gen[4] = 0xFFFFFFE

# Wait for write to complete
t = Ticker()
while regs.mem_gen[7]:
    time.sleep(0.1)
    t.step()
print 'Pattern written'

# Load entire file into memory (because we can!)
data = numpy.fromfile(DDR0_NAME, dtype = numpy.uint32)
print 'Read', len(data), 'rows'

# The two words of the memory generator work independently.
d = data.reshape((len(data)/2, 2))
col0 = d[:, 0]
col1 = d[:, 1]

check_pattern(MEM_GEN_W0, MEM_GEN_S0, col0)
check_pattern(MEM_GEN_W1, MEM_GEN_S1, col1)
