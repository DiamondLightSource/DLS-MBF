#!/usr/bin/env python

# All the programming here is derived from the documentation for the LMK04828
# clock controller from Texas Instruments.  The documentation reference is
# SNAS605 and the datasheet is avaliable at http://www.ti.com/lit/pdf/snas605
# Revision SNAS605AR dated December 2015 was used for this script.

from config_pll import SettingsBase

from driver import PLL


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


# Simple setup with input clock directly exported as system clock
class SysclkSetup(SettingsBase):
    SettingsBase.create_outputs(locals())

    # Configure SDCLKout3 with a copy of SYSREF
    out2_3.CLK_PD = 0           # Enable clock group
    out2_3.SDCLK_PD = 0         # and enable SDCLK
    out2_3.SDCLK_MUX = 1        # Output SYSREF to SDCLK

    # Route 100MHz input from CLKin0 to SYSREF clocking chain
    CLKin0_OUT_MUX = 0          # CLIin0 to SYSREF mux
    SYSREF_CLKin0_MUX = 1       # CLKin0 (100MHz) input
    SYSREF_PD = 0               # Enable sysref
    SYNC_EN = 1                 # Enable SYNC (needed for SYSREF)
    SYSREF_CLR = 0              # Take SYSREF out of reset

# SysclkSetup().write_config(PLL)
# sys.exit()


zero_delay = True
clk_source = 'CLKin0'           # 100 MHz internal crystal
clk_source = 'CLKin1'           # 500 MHz external reference

class Settings(SettingsBase):
    SettingsBase.create_outputs(locals())

    # Enable 2/3 and 8/9 clock groups
    out2_3.CLK_PD = 0
    out8_9.CLK_PD = 0
    out10_11.CLK_PD = 0

    # Configure DCLKout2
    out2_3.DCLK_DIV = 30        # 100 MHz on front panel
    out2_3.DCLK_MUX = 0         # Divider output, no delay

    # Front panel connector on DCLKout10
    out10_11.DCLK_DIV = 6
    out10_11.DCLK_MUX = 0

    # Configure SDCLKout3 with a copy of DCLK
    out2_3.SDCLK_PD = 0         # and enable SDCLK
    out2_3.SDCLK_MUX = 0        # Output DCLK to SDCLK

    SYSREF_CLR = 0              # Take SYSREF out of reset
    SYNC_EN = 0


    # Tried using the TI (actually NI) Clock Design Tool, downloaded from
    # http://www.ti.com/tool/clockdesigntool to compute PLL parameters, but
    # there is an unexpected constraint: the VCXO runs at 100 MHz +-10 kHz,
    # which really rather constrains our options!  Also it appears that the PLL1
    # phase detector can't run much below 1 MHz.
    #
    # In this attempt we can lock onto and regenerate 500 MHz, and the input
    # frequency can be pulled to +-50 kHz before losing lock.  The table below
    # shows the selected frequencies (note PDF is Phase Detector Frequency):
    #                                               Valid range
    #   VCXO frequency: 100 MHz                     99.99 to 100.01 MHz
    #   PLL1 PDF:       33 +1/3 ~= 33.3 MHz         1 to 40 MHz
    #   VCO frequency:  3GHz (VCO1)                 2370-2630 or 2930-3080 MHz
    #   PLL2 PDF:       100 MHz                     < 155 MHz
    #
    # Corresponding counters:
    #
    #   R1 = 3 (input 100 MHz) or 15 (input 500 MHz)
    #   N1 = 3 (dual loop)     or 15 (nested 0 delay)
    #   R2 = 1
    #   N2 = 2 * 15 (must be composite with prescaler in range 2 to 8
    #
    #   PLL1:   R = 15  N = 30
    #   PLL2:   R = 3   N = 7 * 3   (Prescaler and divider)
    #   Fout:   D = 6
    #
    # The governing equations are (f_1 = VCXO frequency, f_2 = VCO frequency,
    # f_ref = input reference, f_out = output, f_fb = chosen feedback frequency,
    # either f_1 or f_out):
    #
    #   PDF1 = f_in / R1 = f_fb / N1    =>  f_fb = (N1 / R1) * f_in
    #   PDF2 = f_1 / R2  = f_2 / N2     =>  f_2  = (N2 / R2) * f_1
    #   f_out = f_2 / D
    #
    # Thus, for f_fb = f_1 (simple dual loop):
    #
    #   f_1   = f_in * N1 / R1
    #   f_2   = f_in * N1 * N2 / (R1 * R2)
    #   f_out = f_in * N1 * N2 / (R1 * R2 * D)
    #
    # and for f_fb = f_out (nested 0-delay dual loop):
    #
    #   f_1   = f_in * R2 * N1 * D / (R1 * N2)
    #   f_2   = f_in * N1 * D / R1
    #   f_out = f_in * N1 / R1

    # PLL1 R (reference) input.
    # Select appropriate reference clock input, either built-in 100 MHz
    # reference or external 500 MHz RF clock.
    if clk_source == 'CLKin0':
        # PLL1 R (reference) input from 100 MHz crystal
        CLKin0_EN = 1
        CLKin1_EN = 0
        CLKin0_OUT_MUX = 2      # 100 MHz on CLKin0 routed to PLL1
        CLKin_SEL_MODE = 0      # Use CLKin0 as PLL1 reference
        CLKin0_R = 3            # PDF1 = 100 / 3 MHz = 33 +1/3
    elif clk_source == 'CLKin1':
        # PLL1 R (reference) input from 500 MHz RF
        CLKin0_EN = 0
        CLKin1_EN = 1
        CLKin0_OUT_MUX = 3
        CLKin1_OUT_MUX = 2      # 500 MHz on CLKin1 routed to PLL1
        CLKin_SEL_MODE = 1      # Use CLKin1 as PLL1 reference
        CLKin1_R = 15           # PDF1 = 500 / 15 MHz = 33 +1/3
    else:
        assert False, 'Invalid clk_source'

    # PLL1 N (feedback) input.
    # Select either OSCin for direct feedback or DCLKout8 for 0-delay
    if zero_delay:
        # For Nested 0-delay Dual Loop Mode we take the PLL1 feedback from the
        # DCLKout8 output.  This will ensure that our output phase has a fixed
        # relationship to our input clock.
        FB_MUX_EN = 1           # Enable feedback mux and
        FB_MUX = 1              # select DCLKout8 as feedback source
        PLL1_NCLK_MUX = 1       # Use feedback mux for PLL1 feedback
        PLL1_N = 15             # PDF1 = 500 / 15 MHz

        # Also need to configure DCLKout8
        out8_9.DCLK_DIV = 6     # Reduce VCO = 3G to 500 MHz output
        out8_9.DCLK_MUX = 0     # Divider only output
    else:
        # For simple Dual Loop Mode we take PLL1 feedback from the PLL1
        # oscillator.
        PLL1_NCLK_MUX = 0       # Use OSCin for PLL1 feedback
        PLL1_N = 3              # Determines VCXO frequency directly

    # PLL1 control.
    PLL1_PD = 0                 # Ensure PLL1 is operating
    OSCin_PD = 0                # Enable OSCin from external VCXO
    PLL1_CP_GAIN = 15           # 1.55 mA charge pump current (from CD Tool)


    # For PLL2 we have less choice once f1 has been determined, the only real
    # choice is between VCO0 running at 2.5GHz or VCO1 running at 3GHz.
    VCO_MUX = 1                 # Use VCO1 running at 3GHz
    OSCin_FREQ = 4              # 255 to 500 MHz frequency range
    PLL2_PD = 0                 # Ensure PLL2 and
    PLL2_PRE_PD = 0             #  prescaler are enabled

    # PLL2 reference R
    PLL2_REF_2X_EN = 0          # No frequency doubling on f1
    PLL2_R = 1                  # PDF2 = f1

    # PLL2 feedback N
    PLL2_NCLK_MUX = 0           # Use direct output feedback
    PLL2_P = 2                  # Feedback N with prescale is 30 for PDF2
    PLL2_N = 15                 # equal to to f1
    PLL2_N_CAL = 15

    # PLL2 integrated loop resistors and capacitors, values taken from Clock
    # Design Tool
    PLL2_LF_R3 = 0              # 200 Ohms
    PLL2_LF_R4 = 0              # 200 Ohms
    PLL2_LF_C3 = 0              # 10 pF
    PLL2_LF_C4 = 0              # 10 pF


    # Lock detect status bits
    PLL1_LD_MUX = 1             # PLL1 DLD (Digital lock detect)
    PLL2_LD_MUX = 2             # PLL2 DLD (Digital lock detect)

    HOLDOVER_EN = 0




#     # Hack: bypass all the above and pass CLKin1 straight through to clock path.
#     CLKin1_OUT_MUX = 0          # Fin internal path
#     VCO_MUX = 2                 # Use CLKin1 as output


s = Settings(PLL)
s.write_config()

# s.SYNC_POL = 1
# s.SYNC_POL = 0
# s.SYSREF_CLR = 0
