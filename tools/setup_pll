#!/usr/bin/env python

# All the programming here is derived from the documentation for the LMK04828
# clock controller from Texas Instruments.  The documentation reference is
# SNAS605 and the datasheet is avaliable at http://www.ti.com/lit/pdf/snas605
# Revision SNAS605AR dated December 2015 was used for this script.

from config_pll import SettingsBase

from driver import PLL


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


# Simple setup with input clock directly exported as system clock
class SysclkSetup(SettingsBase):
    SettingsBase.create_outputs(locals())

    # Configure SDCLKout3 with a copy of SYSREF
    out2_3.CLK_PD = 0           # Enable clock group
    out2_3.SDCLK_PD = 0         # and enable SDCLK
    out2_3.SDCLK_MUX = 1        # Output SYSREF to SDCLK

    # Route 100MHz input from CLKin0 to SYSREF clocking chain
    CLKin0_OUT_MUX = 0          # CLIin0 to SYSREF mux
    SYSREF_CLKin0_MUX = 1       # CLKin0 (100MHz) input
    SYSREF_PD = 0               # Enable sysref
    SYNC_EN = 1                 # Enable SYNC (needed for SYSREF)
    SYSREF_CLR = 0              # Take SYSREF out of reset

# SysclkSetup().write_config(PLL)
# sys.exit()


# 30 / 1 @ 3GHz => 500 MHz
VCO = 1
VCO_DIV = 6
R2 = 1
N2P = 2
N2N = 15

# 3028 / 101 @ 3GHz => 499.670 MHz
VCO = 1
VCO_DIV = 6
R2 = 101
N2P = 4
N2N = 757   # 3028 / 101

# 1549 / 62 @ 2.5GHz => 499.672 MHz
VCO = 0
VCO_DIV = 5
R2 = 61
N2P = 4
N2N = 381


class Settings(SettingsBase):
    SettingsBase.create_outputs(locals())

    # Enable 2/3 and 8/9 clock groups
    out2_3.CLK_PD = 0
    out8_9.CLK_PD = 0
    out10_11.CLK_PD = 0

    # Configure DCLKout2
    out2_3.DCLK_DIV = 5 * VCO_DIV   # 100 MHz on front panel
    out2_3.DCLK_MUX = 0         # Divider output, no delay

    # Front panel connector on DCLKout10
    out10_11.DCLK_DIV = VCO_DIV
    out10_11.DCLK_MUX = 0

    # Configure SDCLKout3 with a copy of DCLK
    out2_3.SDCLK_PD = 0         # and enable SDCLK
    out2_3.SDCLK_MUX = 0        # Output DCLK to SDCLK

    SYSREF_CLR = 0              # Take SYSREF out of reset
    SYNC_EN = 0


    # Tried using the TI (actually NI) Clock Design Tool, downloaded from
    # http://www.ti.com/tool/clockdesigntool to compute PLL parameters, but
    # there is an unexpected constraint: the VCXO runs at 100 MHz +-10 kHz,
    # which really rather constrains our options!  Also it appears that the PLL1
    # phase detector can't run much below 1 MHz.
    #
    # In this attempt we can lock onto and regenerate 500 MHz, and the input
    # frequency can be pulled to +-50 kHz before losing lock.  The table below
    # shows the selected frequencies (note PDF is Phase Detector Frequency):
    #                                               Valid range
    #   VCXO frequency: 100 MHz                     99.99 to 100.01 MHz
    #   PLL1 PDF:       33 +1/3 ~= 33.3 MHz         1 to 40 MHz
    #   VCO frequency:  3GHz (VCO1)                 2370-2630 or 2930-3080 MHz
    #   PLL2 PDF:       100 MHz                     < 155 MHz
    #
    # Corresponding counters:
    #
    #   R1 = 3 (input 100 MHz) or 15 (input 500 MHz)
    #   N1 = 3 (dual loop)     or 15 (nested 0 delay)
    #   R2 = 1
    #   N2 = 2 * 15 (must be composite with prescaler in range 2 to 8
    #
    #   PLL1:   R = 15  N = 30
    #   PLL2:   R = 3   N = 7 * 3   (Prescaler and divider)
    #   Fout:   D = 6
    #
    # The governing equations are (f_1 = VCXO frequency, f_2 = VCO frequency,
    # f_ref = input reference, f_out = output, f_fb = chosen feedback frequency,
    # either f_1 or f_out):
    #
    #   PDF1 = f_in / R1 = f_fb / N1    =>  f_fb = (N1 / R1) * f_in
    #   PDF2 = f_1 / R2  = f_2 / N2     =>  f_2  = (N2 / R2) * f_1
    #   f_out = f_2 / D
    #
    # Thus, for f_fb = f_1 (simple dual loop):
    #
    #   f_1   = f_in * N1 / R1
    #   f_2   = f_in * N1 * N2 / (R1 * R2)
    #   f_out = f_in * N1 * N2 / (R1 * R2 * D)
    #
    # and for f_fb = f_out (nested 0-delay dual loop):
    #
    #   f_1   = f_in * R2 * N1 * D / (R1 * N2)
    #   f_2   = f_in * N1 * D / R1
    #   f_out = f_in * N1 / R1

    # PLL1 R (reference) input, RF clock at 499.96 MHz
    CLKin0_EN = 0
    CLKin1_EN = 1
    CLKin0_OUT_MUX = 3
    CLKin1_OUT_MUX = 2      # 500 MHz on CLKin1 routed to PLL1
    CLKin_SEL_MODE = 1      # Use CLKin1 as PLL1 reference
    CLKin1_R = 15           # PDF1 = 500 / 15 MHz = 33 +1/3

    # PLL1 N (feedback) input from DCLKout8 for Nested 0-delay
    # For Nested 0-delay Dual Loop Mode we take the PLL1 feedback from the
    # DCLKout8 output.  This will ensure that our output phase has a fixed
    # relationship to our input clock.
    FB_MUX_EN = 1           # Enable feedback mux and
    FB_MUX = 1              # select DCLKout8 as feedback source
    PLL1_NCLK_MUX = 1       # Use feedback mux for PLL1 feedback
    PLL1_N = 15             # PDF1 = 500 / 15 MHz
    # Also need to configure DCLKout8
    out8_9.DCLK_DIV = VCO_DIV     # Reduce VCO = 3G to 500 MHz output
    out8_9.DCLK_MUX = 0     # Divider only output

    # PLL1 control.
    PLL1_PD = 0                 # Ensure PLL1 is operating
    OSCin_PD = 0                # Enable OSCin from external VCXO
    PLL1_CP_GAIN = 15           # 1.55 mA charge pump current (from CD Tool)


    # For PLL2 we have less choice once f1 has been determined, the only real
    # choice is between VCO0 running at 2.5GHz or VCO1 running at 3GHz.
    VCO_MUX = VCO               # Use VCO1 running at 3GHz
    OSCin_FREQ = 4              # 255 to 500 MHz frequency range
    PLL2_PD = 0                 # Ensure PLL2 and
    PLL2_PRE_PD = 0             #  prescaler are enabled

    # PLL2 reference R
    PLL2_REF_2X_EN = 0          # No frequency doubling on f1
    PLL2_R = R2                 # PDF2 = f1

    # PLL2 feedback N
    PLL2_NCLK_MUX = 0           # Use direct output feedback
    PLL2_P = N2P                # Feedback N with prescale is 30 for PDF2
    PLL2_N = N2N                # equal to to f1
    PLL2_N_CAL = 15

    # PLL2 integrated loop resistors and capacitors, values taken from Clock
    # Design Tool
    PLL2_LF_R3 = 0              # 200 Ohms
    PLL2_LF_R4 = 0              # 200 Ohms
    PLL2_LF_C3 = 0              # 10 pF
    PLL2_LF_C4 = 0              # 10 pF


    # Lock detect status bits
    PLL1_LD_MUX = 1             # PLL1 DLD (Digital lock detect)
    PLL2_LD_MUX = 2             # PLL2 DLD (Digital lock detect)

    HOLDOVER_EN = 0




#     # Hack: bypass all the above and pass CLKin1 straight through to clock path.
#     CLKin1_OUT_MUX = 0          # Fin internal path
#     VCO_MUX = 2                 # Use CLKin1 as output


s = Settings(PLL)
s.write_config()

# s.SYNC_POL = 1
# s.SYNC_POL = 0
# s.SYSREF_CLR = 0
