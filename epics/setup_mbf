#!/usr/bin/env python

# This script initialises the given MBF target

from __future__ import print_function

import sys
import os
import re
import time


# Load the given configuration file
config_lines = open(sys.argv[1]).readlines()
rule_expr = re.compile(r'^(?!#)([^= ]+) *= *(.*)\n')
config = dict([
    m.groups()
    for m in filter(None, map(rule_expr.match, config_lines))])

# Read required configuration parameters
device_address = config['device_address']
clock_mode = config['clock_mode']
dio_termination = int(config['dio_termination'])


# Load the driver
HERE = os.path.dirname(__file__)
sys.path.append(os.path.join(HERE, '../python'))

from mbf.driver import driver, setup_pll, setup_adc, setup_dac, scan_idelay

# If no device address specifed then default to card zero.
if not device_address:
    device_address = 0
regs = driver.Registers(device_address)

# Check firmware version first
FIRMWARE_COMPAT_VERSION = driver.constants.FIRMWARE_COMPAT_VERSION
assert regs.SYS.VERSION.FIRMWARE == FIRMWARE_COMPAT_VERSION, \
    'Firmware version mismatch: read %u, expected %u' % (
        regs.SYS.VERSION.FIRMWARE, FIRMWARE_COMPAT_VERSION)
if FIRMWARE_COMPAT_VERSION == driver.constants.FIRMWARE_COMPAT_UNSTABLE:
    print('UNSTABLE FIRMWARE VERSION')

# Before touching the hardware and clocks ensure the DAC output is off
regs.CTRL.CONTROL.OUTPUT = 0

# Hardware initialisation
setup_pll.setup_pll(regs, clock_mode)
setup_adc.setup_adc(regs)
scan_idelay.scan_idelay(regs, 0, 10240)
setup_dac.setup_dac(regs)
# Read and discard events generated by idelay scan
regs.read_events()

# Set the digital IO termination
regs.SYS.CONTROL.DIO_TERM = dio_termination
