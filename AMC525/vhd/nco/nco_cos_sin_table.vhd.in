library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

use work.nco_defs.all;

entity nco_cos_sin_table is
    generic (
        LOOKUP_DELAY : natural
    );
    port (
        clk_i : in std_logic;

        addr_i : in cos_sin_addr_t;
        cos_sin_o : out cos_sin_19_t
    );
end;

architecture arch of nco_cos_sin_table is
    subtype cos_sin_data_t is std_logic_vector(35 downto 0);
    type lookup_t is array(0 to 1023) of cos_sin_data_t;
    signal table : lookup_t := (
        @TABLE_BODY@
    );

    attribute ram_style : string;
    attribute ram_style of table : signal is "BLOCK";

    signal addr : cos_sin_addr_t;
    signal data : cos_sin_data_t := (others => '0');
    signal data_pl : cos_sin_data_t := (others => '0');

    function bits_to_cos_sin(data : std_logic_vector) return cos_sin_19_t is
        variable result : cos_sin_19_t;
    begin
        result.cos := signed('0' & data(17 downto 0));
        result.sin := signed('0' & data(35 downto 18));
        return result;
    end;

begin
    -- To ensure that all the required registers are folded into the lookup
    -- table, we need the following 4 stages:
    --      addr_i => addr => data_pl => data => cos_sin_o
    assert LOOKUP_DELAY = 4 severity failure;

    -- Double-buffered table lookup to help with BRAM registers.
    process (clk_i) begin
        if rising_edge(clk_i) then
            addr <= addr_i;
            data_pl <= table(to_integer(addr));
            data <= data_pl;
            cos_sin_o <= bits_to_cos_sin(data);
        end if;
    end process;
end;
