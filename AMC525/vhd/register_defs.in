## Input definitions for registers
##
## This file is processed to generate the following:
##  - register_defs.vhd used to generate firmware
##  - register_defs.h used to build control system interface
##  - structured definitions used by driver.py for control debugging
##  - registers.pdf/.html for documentation

:IDELAY     RW
    # Write new IDELAY value, returns current IDELAY setting
    .VALUE      5       RW
    # Enable write to IDELAY, so write number of form 0x1xx
    .WRITE      @8      W
    -           3
    # Enable increment or decrement of IDELAY
    .STEP       @12     W
    # Increment if 1, decrement if 0
    .INC_DECN           W


# Min/Max/Sum.  This functional block computes the minimum, maximum, sum, and
# sum of squares of each bunch for an extended period of time.  A sampling
# period is ended by reading the the .COUNT register, and then the individual
# bunches can be read out.  Overflow can happen after 65536 turns, so readout
# should occur at least this frequently.
:!MMS
    # Reading this register swaps MMS banks and returns the number of turns
    # recorded in the now current readout bank.  Read the READOUT register
    # repeatedly to read the bank.
    COUNT       R
        # Number of turns since last MMS bank exchange (less 1)
        .TURNS      29
        # Set if the turn count has overflowed
        .TURNS_OVFL
        # Set if any of the sum fields have overflowed
        .SUM_OVFL
        # Set if any of the sum of squared fields have overflowed
        .SUM2_OVFL

    # Read four times for each bunch, returning the following data for each
    # bunch:
    *OVERLAY    READOUT     R
        MIN_MAX
            # Minimum value during capture period
            .MIN        16
            # Maximum value during capture period
            .MAX        16
        # Sum of all values during capture period
        SUM
        # Sum of squares of all values during capture period (low order bits)
        SUM2_LOW
        SUM2_HIGH
            # High order bits of sum of squares
            .SUM2       16


# These occupy addresses 0x0000..0x1FFF
#
# Used for top level hardware management
!SYS
    # No fields yet defined
    VERSION     R

    # Configuration information
    INFO        R
        # Number of taps in the ADC compensation filter
        .ADC_TAPS       8
        # Number of taps in the bunch-by-bunch feedback filter
        .BUNCH_TAPS     8
        # Number of taps in the DAC pre-emphasis filter
        .DAC_TAPS       8

    # System status register
    STATUS      R
        # Set if ADC clock is currently good
        .DSP_OK
        -
        # Set if FMC500 VCXO power ok
        .VCXO_OK
        # Set if FMC500 ADC power ok
        .ADC_OK
        # Set if FMC500 DAC power ok
        .DAC_OK
        # Set if FMC500 PLL status LD1: VCXO locked
        .PLL_LD1
        # FMC500 PLL status LD2: set if VCO locked
        .PLL_LD2
        # FMC500 DAC interrupt request
        .DAC_IRQN
        # FMC500 temperature alert
        .TEMP_ALERT

    # Control register
    CONTROL     RW
        -           3
        # FMC500 PLL clkin sel0
        .PLL_SEL0
        # FMC500 PLL clkin sel1
        .PLL_SEL1
        # FMC500 PLL sync
        .PLL_SYNC
        # ADC power down (leave at 0 for normal operation)
        .ADC_PDWN
        # DAC reset (leave at 0 for normal operation)
        .DAC_RSTN

    # ADC DCO IDELAY control
    :IDELAY     ADC_IDELAY
        # Set if ADC PLL not locked, write to trigger reset of ADC PLL.
        .PLL_LOCK   @31     RW

    # FMC500 SPI control.  Reads and writes to the three SPI devices on the
    # FMC500M ADC/DAC card.
    FMC_SPI     RW
        # Data to write and returned data
        .DATA       8       RW
        # Register address within selected device
        .ADDRESS    15      W
        # Select device to address:
        #
        # === ================================================
        # 0   Clock controller, LMK04826B
        # 1   ADC, AD9684
        # 2   DAC, AD9122
        # === ================================================
        .SELECT     2 @29   W
        # Set to 1 to trigger a read cycle on the selected SPI address, follow
        # up by reading from this register to read the result
        .RW_N       @31     W

    # Revolution clock IDELAY control
    :IDELAY     REV_IDELAY


# These occupy addresses 0x2000..02x7FF
#
# Used for shared DSP control
!CTRL
    # Captures single clock pulsed events, resets on read.
    PULSED      R
        # Set if an AXI data error occurs when writing to slow memory.  Should
        # never occur.
        .DRAM1_ERROR

    # Control over central inter-channel multiplexers, and related global
    # settings.  All MUX fields should be set to the same value for normal
    # operation: for independent channels, set all MUX bits to 0, for coupled
    # channels set to 1.
    CONTROL     RW
        # ADC mux: if set input to channel 0 FIR has copy of channel 1 ADC
        .ADC_MUX
        # NCO0 mux: if set channel 0 NCO0 has sin data from channel 1
        .NCO0_MUX
        # NCO1 mux: if set channel 0 NCO1 has sin data from channel 1
        .NCO1_MUX
        # Bank mux: if set channel 0 bank selection is copy of bank selection
        # from channel 1.
        .BANK_MUX
        # If set to 1 the output from the corresponding channel is looped back
        # to the ADC input.  Set to 0 for normal operation.
        .LOOPBACK   2
        # Set to 1 to enable output to DAC on the corresponding channel,
        # otherwise zero is output.
        .OUTPUT     2

    # Control and readout registers for capture to fast memory.
    !MEM
        CONFIG      RW
            # Select pattern of data written to memory according to the table
            # below:
            #
            # ======= ==================== ====================
            # Mux     Ch0                  Ch1
            # ======= ==================== ====================
            # 0       ADC0                 ADC1
            # 1       ADC0                 FIR1
            # 2       ADC0                 DAC1
            # 3       ADC0                 FIR0
            # 4       FIR0                 ADC1
            # 5       FIR0                 FIR1
            # 6       FIR0                 DAC1
            # 7       FIR0                 DAC0
            # 8       DAC0                 ADC1
            # 9       DAC0                 FIR1
            # 10      DAC0                 DAC1
            # 11      DAC0                 ADC0
            # 12      ADC1                 FIR1
            # 13      FIR1                 DAC1
            # 14      DAC1                 ADC1
            # 15      0                    0
            # ======= ==================== ====================
            .MUX_SELECT     4
            # Gain selection for FIR channel 0 capture to DRAM.  Either bottom
            # 16 bits or top 16 bits of 24 bit FIR input.
            .FIR0_GAIN       1
            # Gain selection for FIR channel 1 capture to DRAM.
            .FIR1_GAIN       1

        COUNT       RW
            # Number of words to capture to memory after STOP event
            .COUNT          28

        # Only valid after STOP has been triggered, returns the write address in
        # bytes at the time of the trigger event
        ADDRESS     R

        *RW
            # Captures single pulse events, reset on each read
            PULSED      R
                # Set if overflow occurs through the FIR -> DRAM scaling.
                .FIR_OVF    2

            # Write to this register to trigger the select actions
            COMMAND     WP
                # Starts capture to memory
                .START
                # Stops capture to memory after specified post trigger capture
                # count has completed.  Has same effect as enabled external
                # trigger event if configured.
                .STOP
                # Resets all error bits
                .RESET

        # Active status bits
        STATUS      R
            # DRAM data capture error bits.  We hope to never see any of these
            # bits set.  The bits correspond to AXI errors as follows:
            #
            # ======= ===============================================
            # Bit     Error
            # ======= ===============================================
            # 0       Data error: data overrun while writing
            # 1       Address error: invalid AXI address
            # 2       Data response error: memory write refused
            # ======= ===============================================
            #
            # None of the above errors should ever occur!
            .ERRORS     3
            # This bit is set if any of the data capture error bits is set.
            .ERROR
            # This bit is set during capture to DRAM
            .ENABLE

    # Trigger management and control.  Seven trigger sources are available, and
    # three trigger targets can be configured.  The following trigger sources
    # are managed as masks for a variety of registers below:
    #
    # ======= ===============================================
    # Bit     Source
    # ======= ===============================================
    # 0       Soft trigger
    # 1       External event trigger
    # 2       Postmortem trigger
    # 3       ADC 0 motion trigger
    # 4       ADC 1 motion trigger
    # 5       State 0 trigger
    # 6       State 1 trigger
    # ======= ===============================================
    #
    # The following trigger targets are configured here:
    #
    # ======= ===============================================
    # DRAM0   Stop capture to fast memory
    # SEQ0    Start sequencer for DSP0
    # SEQ1    Start sequencer for DSP1
    # ======= ===============================================
    !TRG
        *RW
            PULSED      R
                # Each bit records a raw trigger event from the corresponding
                # trigger source
                .TRIGGERS   7
                # Set if the blanking input has seen a rising edge
                .BLANKING
            # Pulsed trigger control events
            CONTROL     WP
                # Start turn clock synchronisation
                .SYNC_TURN
                # Request turn clock sample
                .SAMPLE_TURN
                # Arm sequencer 0 trigger
                .SEQ0_ARM
                # Disarm sequencer 0 trigger
                .SEQ0_DISARM
                # Arm sequencer 1 trigger
                .SEQ1_ARM
                # Disarm sequencer 1 trigger
                .SEQ1_DISARM
                # Arm DRAM0 trigger
                .DRAM0_ARM
                # Disarm DRAM0 trigger
                .DRAM0_DISARM
                # Generate soft trigger event
                .TRIGGER

        # Trigger status readbacks
        STATUS      R
            # Start clock synchronisation busy
            .SYNC_BUSY
            # ADC clock phase after turn synchronisation
            .SYNC_PHASE
            # Synchronisation error detected
            .SYNC_ERROR
            # Waiting for turn clock sample
            .SAMPLE_BUSY
            # ADC clock phase after sample
            .SAMPLE_PHASE
            # Sequencer 0 trigger armed
            .SEQ0_ARMED
            # Sequencer 1 trigger armed
            .SEQ1_ARMED
            # DRAM0 trigger armed
            .DRAM0_ARMED
            # Turn clock counter captured by sample
            .SAMPLE     10 @16

        # Trigger event sources.  When a target is triggered the source of the
        # trigger is latched into the corresponding source mask below.  The
        # source mask is reset when the target is armed.
        SOURCES     R
            # Sequencer 0 trigger source mask
            .SEQ0       7
            -
            # Sequencer 1 trigger source mask
            .SEQ1       7
            -
            # DRAM0 trigger source mask
            .DRAM0      7

        !CONFIG
            # Turn clock configuration setup
            TURN        RW
                # Configures the internal revolution clock frequency.  Set to
                # the number of machine bunches-1
                .MAX_BUNCH      10
                # Turn clock offset for channel 0 from sync trigger
                .DSP0_OFFSET    10
                # Turn clock offset for channel 1 from sync trigger
                .DSP1_OFFSET    10

            # Blanking windows
            BLANKING    RW
                # DSP 0 blanking window (in turns)
                .DSP0           16
                # DSP 1 blanking window (in turns)
                .DSP1           16

            SEQ0        RW
                # Sequencer 0 trigger delay
                .DELAY          16

            SEQ1        RW
                # Sequencer 1 trigger delay
                .DELAY          16

            DRAM0       RW
                # DRAM0 trigger delay
                .DELAY          16

            # Sequencer trigger configuration
            TRIG_SEQ    RW
                # Sequencer 0 trigger enable mask
                .ENABLE0        7
                -
                # Sequencer 0 blanking enable mask
                .BLANKING0      7
                -
                # Sequencer 1 trigger enable mask
                .ENABLE1        7
                -
                # Sequencer 1 blanking enable mask
                .BLANKING1      7

            # DRAM0 trigger configuration
            TRIG_DRAM   RW
                # Trigger enable mask
                .ENABLE         7
                -
                # Blanking enable mask
                .BLANKING       7
                -
                # Turn clock selection
                .TURN_SEL       1
                # Blanking pulse selection mask
                .BLANKING_SEL   2


# These occupy addresses 0x3000..0x37FF and 0x3800..3FFF
#
# Used for channel specific DSP control, each channel has its own bank of
# registers.
!DSP
    # Sets NCO0 frequency
    NCO0_FREQ   RW

    # Input signal processing
    !ADC
        CONFIG       W
            # Input threshold for reporting input overflow
            .THRESHOLD  14
            # Optional 1 clock delay on ADC input.  Probably not useful.
            .DELAY      1
            # Limit threshold for min/max/sum bunch motion event detector
            .DELTA      16
        *RW
            EVENTS      R
                # Set if input data exceeds ADC input limit setting
                .INP_OVF
                # Set if overflow detected during input compensation filter
                .FIR_OVF
                # Set if any of the ADC min/max/sum accumulators overflow
                .MMS_OVF
                # Set when ADC min/max/sum motion exceeds configured threshold
                .DELTA
            # Writing to this register generates a pulse on the selected bits
            COMMAND      WP
                # Starts block write to ADC fast FIR taps
                .WRITE
                # Resets ADC min/max event detector to enable further events
                .RESET_DELTA
        # After triggering write start, input compensation taps are written to
        # this register in sequence.
        TAPS        W
        # Bunch by bunch motion for ADC input data, after compensation filter,
        # see MMS_.
        :MMS

    # Shared bunch by bunch configuration
    !BUNCH
        CONFIG      W
            # Determines bunch bank to be written, resets write pointer
            .BANK       2
        # Repeated writes to this register update the configuration for
        # successive bunches
        BANK        W
            # Selects FIR to apply to this bunch
            .FIR_SELECT     2
            # Output gain
            .GAIN           13
            # Enable FIR output for this bunch
            .FIR_ENABLE
            # Enable NCO0 output
            .NCO0_ENABLE
            # Enable NCO1 output
            .NCO1_ENABLE


    # Bunch by bunch filter
    !FIR
        *RW
            EVENTS      R
                .OVERFLOW
            CONFIG      W
                # Configures which group of taps will be written when writing to
                # the TAPS register.
                .BANK       2
                # Determines decimation count: set this to target decimation
                # count less 1.
                .LIMIT      7
                # Scaling factor for decimated data, needs to be set up
                # correctly to avoid silent overflow.
                .SHIFT      3
        # Writing to this register programs the FIR taps for the selected bank.
        # The tap write counter is reset by any write to the config register.
        TAPS        W

    # Output signal processing
    !DAC
        # Output to DAC configuration control
        CONFIG      W
            # Output delay for final DAC output
            .DELAY          10
            # Gain for FIR output
            .FIR_GAIN       4
            # Gain for NCO0 output (NCO1 gain is under sequencer control)
            .NCO0_GAIN      4
            # Global control for NCO0 enable
            .NCO0_ENABLE
            # Select MMS source: before or after output FIR.  If 0 we select the
            # output before the filter
            .MMS_SOURCE
            # Select stored data source, before or after output FIR.
            .DRAM_SOURCE
        *RW
            EVENTS      R
                # Set when overflow in FIR data detected in DAC output
                .FIR_OVF
                # Set when DAC output multiplexer detects overflow
                .MUX_OVF
                # Set if any of the DAC min/max/sum accumulators overflow
                .MMS_OVF
                # Set if overflow detected during output preemphasis filter
                .OUT_OVF
            # Writing to this register generates a pulse on the selected bits
            COMMAND      WP
                # Starts block write to DAC fast FIR taps
                .WRITE
        # After triggering write start, input compensation taps are written to
        # this register in sequence.
        TAPS        W
        # Bunch by bunch motion for DAC input data, before pre-emphasis filter
        :MMS

    # Sequencer control
    !SEQ
        *RW
            STATUS      R
                # Current sequencer state
                .PC         3
                # Set if sequencer busy
                .BUSY
                # Current super sequencer counter
                .SUPER      10
            COMMAND     WP
                # Interrupts sequencer if running and resets to state 0
                .ABORT
                # Initiates write to selected memory block
                .WRITE

        CONFIG      RW
            # Starting sequencer program counter when triggered
            .PC             3
            # Sequencer state to generate trigger event
            .TRIGGER        3
            # Starting super sequencer counter when triggered
            .SUPER_COUNT    10
            # Identifies which memory block is written when writing to the WRITE
            # register:
            #
            # ===== =================== ====================================
            # \     Name                Target
            # ===== =================== ====================================
            # 0     ``STATE``           sequencer program memory
            # 1     ``DET_WINDOW``      detector window memory
            # 2     ``SUPER_STATE``     super sequencer memory
            # ===== =================== ====================================
            .TARGET         2

        # Three separate functions are overlaid over the STATE, DET_WINDOW, and
        # SUPER_STATE register which occupy the same address.  Which register is
        # used is determined by the value written to CONFIG.TARGET above.
        *UNION      WRITE
            # Writing to this register updates the selected internal sequencer
            # memory bank.  For the sequencer state a sequence of 8 writes is
            # required to write a complete state, and so a sequence of 64 writes
            # updates the sequencer program memory.
            *OVERLAY    STATE       W
                # Starting frequency for this sweep
                START_FREQ
                # Frequency step for this sweep
                DELTA_FREQ
                DWELL_TIME
                    # Number of turns to capture for one detector cycle
                    .DWELL          16
                CONFIG
                    # Total number of samples in this sweep
                    .CAPTURE        12
                    # Bunch bank select for this sequencer state
                    .BANK           2
                    # Select sweep NCO gain
                    .NCO_GAIN       4
                    # If set the sweep window is enabled
                    .ENA_WINDOW
                    # Whether to store this output from the sequencer
                    .ENA_WRITE
                    # Whether to respect the blanking input
                    .ENA_BLANK
                    # Sweep output enable
                    .ENA_NCO
                # Detector window advance.
                WINDOW_RATE
                HOLDOFF
                    # Number of turns to wait after changing frequency and
                    # before starting detector capture
                    .HOLDOFF        16

                # Two extra writes are required to pad the state setup to 8
                # words.
                PADDING

            # Writing to this register updates the detector window.  A sequence
            # of 1024 writes is needed to fill this memory
            DET_WINDOW      W

            # Writing to this register updates the super sequencer offset
            # memory, up to 1024 states can be written
            SUPER_STATE     W

    # Detector control
    !DET
        # Configures global behaviour of the four detectors
        CONFIG      RW
            # Select data input source: 0 selects ADC data, 1 selects scaled
            # FIR data
            .SELECT
            # Output scaling for detector 0
            .SCALE0     2
            # Output enable for detector 0
            .ENABLE0
            # Output scaling for detector 1
            .SCALE1     2
            # Output enable for detector 1
            .ENABLE1
            # Output scaling for detector 2
            .SCALE2     2
            # Output enable for detector 2
            .ENABLE2
            # Output scaling for detector 3
            .SCALE3     2
            # Output enable for detector 3
            .ENABLE3
            # Select which bunch bank is written to when writing to the detector
            # bunch register
            .BANK       2 @30
        *RW
            # Captures events generated by the detector, reset on readout
            EVENTS      R
                # For each detector, set if output overflow was detected when
                # transmitting detector result
                .OUTPUT_OVFL    4
                # For each detector, set if data was lost.  This can happen if
                # detector data is written too rapidly, but should not happen
                # during normal operation.
                .UNDERRUN       4
            COMMAND     WP
                # Triggers start of write to detector bunch enable memory.
                .WRITE
                # Resets output address for detector capture
                .RESET
        # Writing to this register programs the bunch enable memory for the
        # detector selected by writing to the CONFIG BANK selection.  First
        # reset the address by setting ``DSP.DET.COMMAND.WRITE`` and then write
        # 32 enable bits at a time until all bunches have been programmed.
        BUNCH       W


# The following interrupt sources are defined
:INTERRUPTS     R
    # DRAM0 data capture becomes busy
    .DRAM_BUSY
    # DRAM0 data capture completed
    .DRAM_DONE
    # DRAM0 data capture trigger.  Capture will complete shortly after this
    # trigger is seen.
    .DRAM_TRIGGER
    # Sequencer start trigger seen, one bit for each channel.
    .SEQ_TRIGGER    2
    # Sequencer becomes busy (should occur immediately after trigger), one bit
    # for each channel.
    .SEQ_BUSY       2
    # Sequencer complete, no longer busy, one bit for each channel.
    .SEQ_DONE       2
