# Input definitions for registers

# The control register address space consists of 16384 32-bit words
# organised into four active banks with the following addressing:
#
#  Address         Alias   Controlled bank
#  =============== ======= ============================================
#  0x0000..0x0FFF  SYS     System registers: top level hardware control
#  0x2000..0x27FF  CTRL    DSP master control
#  0x2800..0x2FFF          (unused)
#  0x3000..0x37FF  DSP0    DSP 0 control
#  0x3800..0x3FFF  DSP1    DSP 1 control
#
# The active registers in each bank are identified and named below.


:IDELAY     RW
    # Write new IDELAY value, returns current IDELAY setting
    .VALUE      5       RW
    # Enable write to IDELAY, so write number of form 0x1xx
    .WRITE      @8      W
    -           3
    # Enable increment or decrement of IDELAY
    .STEP       @12     W
    # Increment if 1, decrement if 0
    .INC_DECN           W

:MMS
    # Reading this register swaps MMS banks and returns the number of turns
    # recorded in the now current readout bank.  Read the READOUT register
    # repeatedly to read the bank.
    COUNT       R
        # Number of turns since last MMS bank exchange
        .TURNS      29
        # Set if the turn count has overflowed
        .TURNS_OVFL
        # Set if any of the sum fields have overflowed
        .SUM_OVFL
        # Set if any of the sum of squared fields have overflowed
        .SUM2_OVFL

    # Read four times for each bunch, returning the following data for each
    # bunch:
    #
    #   ======= ======= =====================================
    #   Word    Bits    Value
    #   ======= ======= =====================================
    #   0       15:0    Minimum value during capture period
    #   0       31:16   Maximum value during capture period
    #   1       31:0    Sum of all values during capture
    #                   period
    #   3:2     47:0    Sum of squares of values during
    #                   capture period
    #   ======= ======= =====================================
    ##
    ## Note the layout of the above table is for .rst generation into a fixed
    ## width target.
    READOUT     R


# System registers
# These occupy addresses 0x0000..0x0FFF
# Used for top level hardware management
SYS
    # No fields yet defined
    VERSION     R

    # System status register
    STATUS      R
        # Set if ADC clock is currently good
        .DSP_OK
        # Set during capture to DDR0
        .DRAM0_ENABLE
        # Set if FMC500 VCXO power ok
        .VCXO_OK
        # Set if FMC500 ADC power ok
        .ADC_OK
        # Set if FMC500 DAC power ok
        .DAC_OK
        # Set if FMC500 PLL status LD1: VCXO locked
        .PLL_LD1
        # FMC500 PLL status LD2: set if VCO locked
        .PLL_LD2
        # FMC500 DAC interrupt request
        .DAC_IRQN
        # FMC500 temperature alert
        .TEMP_ALERT

    # Control register
    CONTROL     RW
        -           3
        # FMC500 PLL clkin sel0
        .PLL_SEL0
        # FMC500 PLL clkin sel1
        .PLL_SEL1
        # FMC500 PLL sync
        .PLL_SYNC
        # ADC power down (leave at 0 for normal operation)
        .ADC_PDWN
        # DAC reset (leave at 0 for normal operation)
        .DAC_RSTN
        # Enable DAC test data generation
        .DAC_TESTMODE

    # ADC DCO IDELAY control
    # W  [4:0]      IDELAY value
    # W  [8]        Enable write to IDELAY, so write number of form 0x1xx
    # W  [12]       Enable increment or decrement of IDELAY
    # W  [13]       Increment if 1, decrement if 0
    # W  [31]       Force reset of ADC PLL
    # R  [4:0]      Current IDELAY setting
    # R  [31]       Set if ADC PLL not locked
    :IDELAY     ADC_IDELAY
        # Set if ADC PLL not locked, write to trigger reset of ADC PLL.
        .PLL_LOCK   @31     RW

    # FMC500 SPI control.  Reads and writes to the three SPI devices on the
    # FMC500M ADC/DAC card.
    FMC_SPI     RW
        # Data to write and returned data
        .DATA       8       RW
        # Register address within selected device
        .ADDRESS    15      W
        # Select device to address:
        #
        # :0: Clock controller, LMK04826B
        # :1: ADC, AD9684
        # :2: DAC, AD9122
        .SELECT     2 @29   W
        # Set to 1 to trigger a read cycle on the selected SPI address, follow
        # up by reading from this register to read the result
        .RW_N       @31     W

    # DAC test data pattern
    DAC_TEST    2 RW

    # Revolution clock IDELAY control
    :IDELAY     REV_IDELAY


# Control registers
# These occupy addresses 0x2000..02x7FF
# Used for shared DSP control
CTRL
    # Captures single clock pulsed events.  Write a bit pattern to reset those
    # bits and latch the current state.
    # RW [0]        Set if DRAM0 data error detected
    # RW [1]        Set if DRAM0 address error detected
    # RW [2]        Set if DRAM0 write error detected
    # RW [3]        Set if DRAM1 write error detected
    PULSED

    # Miscellaneous control
    # RW [0]    ADC mux: if set channel 0 has copy of channel 1 ADC
    # RW [1]    NCO0 mux: if set channel 0 has sin data from channel 1
    # RW [2]    NCO1 mux: if set channel 0 has sin data from channel 1
    # RW [4:3]  Channel loopback
    # RW [6:5]  Channel output enable
    CONTROL

    MEM
        # Control and readout registers
        CONFIG
            CONFIG
            COUNT

        # Overlaid pulse command and address readback registers
        *RW
            ADDRESS     R
            COMMAND     W

        STATUS

    TRG
        # Pulsed trigger control events
        # W  [0]        Start turn clock synchronisation
        # W  [1]        Request turn clock sample
        # W  [2]        Arm sequencer 0 trigger
        # W  [3]        Disarm sequencer 0 trigger
        # W  [4]        Arm sequencer 1 trigger
        # W  [5]        Disarm sequencer 1 trigger
        # W  [6]        Arm DRAM0 trigger
        # W  [7]        Disarm DRAM0 trigger
        # W  [8]        Generate soft trigger event
        # Capture trigger events
        # R  [0]        Soft trigger
        # R  [1]        External event trigger
        # R  [2]        Postmortem trigger
        # R  [3]        ADC 0 motion trigger
        # R  [4]        ADC 1 motion trigger
        # R  [5]        State 0 trigger
        # R  [6]        State 1 trigger
        *RW
            PULSED      R
            CONTROL     W

        READBACK
            # Trigger status readbacks
            #     7[0]        Start clock synchronisation busy
            #     7[1]        ADC clock phase after turn synchronisation
            #     7[2]        Synchronisation error detected
            #     7[3]        Waiting for turn clock sample
            #     7[4]        ADC clock phase after sample
            #     7[5]        Sequencer 0 trigger armed
            #     7[6]        Sequencer 1 trigger armed
            #     7[7]        DRAM0 trigger armed
            #     7[25:16]    Turn clock counter captured by sample
            STATUS

            # R   8       Trigger event sources.
            #     8[6:0]      Sequencer 0 trigger source mask
            #     8[14:8]     Sequencer 1 trigger source mask
            #     8[22:16]    DRAM0 trigger source mask
            SOURCES

        CONFIG
            # RW  9       Turn clock configuration setup
            #     9[9:0]      Maximum bunch count
            #     9[19:10]    DSP 0 turn clock offset
            #     9[29:20]    DSP 1 turn clock offset
            TURN_SETUP

            # RW  10      Blanking windows
            #     10[15:0]    DSP 0 blanking window (in turns)
            #     10[31:16]   DSP 1 blanking window (in turns)
            BLANKING

            # RW  11[23:0]    Sequencer 0 trigger delay
            DELAY_SEQ_0

            # RW  12[23:0]    Sequencer 1 trigger delay
            DELAY_SEQ_1

            # RW  13[23:0]    DRAM0 trigger delay
            DELAY_DRAM

            # RW  14      Sequencer trigger configuration
            #     14[6:0]     Sequencer 0 trigger enable mask
            #     14[14:8]    Sequencer 0 blanking enable mask
            #     14[22:16]   Sequencer 1 trigger enable mask
            #     14[30:24]   Sequencer 1 blanking enable mask
            TRIG_SEQ

            # RW  15      DRAM0 trigger configuration
            #     15[6:0]     DRAM trigger enable mask
            #     15[14:8]    DRAM blanking enable mask
            #     15[16]      DRAM turn clock selection
            #     15[18:17]   DRAM blanking pulse selection mask
            TRIG_DRAM


# DSP registers
# These occupy addresses 0x3000..0x37FF and 0x3800..3FFF
# Used for channel specific DSP control
DSP
    MISC
        # W   Strobed bits
        # R   General status bits
        # RW  Latched pulsed events
        *RW
            STATUS      R
            STROBE      W

        PULSED

        NCO0_FREQ

    # Input signal processing
    ADC
        # R   31:0    Read MMS count and switch banks
        # R   31:0    Read and reset MMS bunch entries
        # W   13:0    Configure data input limit
        # W   15      Configure ADC fine delay
        # W   31:16   Configure MMS event limit
        # W   31:7    Write FIR taps
        LIMIT
        TAPS
        :MMS

    # Shared bunch by bunch configuration
    BUNCH
        #  4   W  1:0      Determines bunch bank to be written
        #  5   W           Configure selected bank
        CONFIG
        BANK

    # Bunch by bunch filter
    FIR
        CONFIG
        TAPS

    # Output signal processing
    DAC
        # R   31:0    Read MMS count and switch banks
        # W   9:0     Configure DAC output delay
        # W  105:12   NCO 0 gain
        # W  109:16   NCO 1 gain
        # W   24:20   FIR gain
        # W   25      FIR enable
        # W   26      NCO 0 enable
        # W   27      NCO10 enable
        # R   31:9    Read and reset MMS bunch entries
        # W   31:7    Write FIR taps
        CONFIG
        TAPS
        :MMS

    # Sequencer control
    SEQ
        # W   0       Abort sequencer if running
        # W   1       Initiate block memory write sequence
        # R   2:0     Current sequencer program counter
        # R   4       Set if sequencer busy
        # R   17:8    Current super sequencer state
        *RW
            STATUS      R
            COMMAND     W

        # RW  2:0     Target sequencer program counter
        # RW  6:4     Sequencer state to generate event
        # RW  17:8    Target super sequencer state
        # RW  29:28   Block memory to write
        #             0 => sequencer program memory
        #             1 => detector window memory
        #             2 => super sequencer memory
        CONFIG
        WRITE

    # Detector control
    DET
        CONFIG
        *RW
            EVENTS      R
            COMMAND     W
        BUNCH
