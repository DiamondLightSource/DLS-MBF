# Input definitions for registers

# The control register address space consists of 16384 32-bit words
# organised into four active banks with the following addressing:
#
#  Address         Alias   Controlled bank
#  =============== ======= ============================================
#  0x0000..0x0FFF  SYS     System registers: top level hardware control
#  0x2000..0x27FF  CTRL    DSP master control
#  0x2800..0x2FFF          (unused)
#  0x3000..0x37FF  DSP0    DSP 0 control
#  0x3800..0x3FFF  DSP1    DSP 1 control
#
# The active registers in each bank are identified and named below.


:IDELAY     RW
    # Write new IDELAY value, returns current IDELAY setting
    .VALUE      5       RW
    # Enable write to IDELAY, so write number of form 0x1xx
    .WRITE      @8      W
    -           3
    # Enable increment or decrement of IDELAY
    .STEP       @12     W
    # Increment if 1, decrement if 0
    .INC_DECN           W

:!MMS
    # Reading this register swaps MMS banks and returns the number of turns
    # recorded in the now current readout bank.  Read the READOUT register
    # repeatedly to read the bank.
    COUNT       R
        # Number of turns since last MMS bank exchange
        .TURNS      29
        # Set if the turn count has overflowed
        .TURNS_OVFL
        # Set if any of the sum fields have overflowed
        .SUM_OVFL
        # Set if any of the sum of squared fields have overflowed
        .SUM2_OVFL

    # Read four times for each bunch, returning the following data for each
    # bunch:
    #
    #   ======= ======= =====================================
    #   Word    Bits    Value
    #   ======= ======= =====================================
    #   0       15:0    Minimum value during capture period
    #   0       31:16   Maximum value during capture period
    #   1       31:0    Sum of all values during capture
    #                   period
    #   3:2     47:0    Sum of squares of values during
    #                   capture period
    #   ======= ======= =====================================
    ##
    ## Note the layout of the above table is for .rst generation into a fixed
    ## width target.
    READOUT     R


# System registers
# These occupy addresses 0x0000..0x0FFF
# Used for top level hardware management
!SYS
    # No fields yet defined
    VERSION     R

    # System status register
    STATUS      R
        # Set if ADC clock is currently good
        .DSP_OK
        # Set during capture to DDR0
        .DRAM0_ENABLE
        # Set if FMC500 VCXO power ok
        .VCXO_OK
        # Set if FMC500 ADC power ok
        .ADC_OK
        # Set if FMC500 DAC power ok
        .DAC_OK
        # Set if FMC500 PLL status LD1: VCXO locked
        .PLL_LD1
        # FMC500 PLL status LD2: set if VCO locked
        .PLL_LD2
        # FMC500 DAC interrupt request
        .DAC_IRQN
        # FMC500 temperature alert
        .TEMP_ALERT

    # Control register
    CONTROL     RW
        -           3
        # FMC500 PLL clkin sel0
        .PLL_SEL0
        # FMC500 PLL clkin sel1
        .PLL_SEL1
        # FMC500 PLL sync
        .PLL_SYNC
        # ADC power down (leave at 0 for normal operation)
        .ADC_PDWN
        # DAC reset (leave at 0 for normal operation)
        .DAC_RSTN
        # Enable DAC test data generation
        .DAC_TESTMODE

    # ADC DCO IDELAY control
    :IDELAY     ADC_IDELAY
        # Set if ADC PLL not locked, write to trigger reset of ADC PLL.
        .PLL_LOCK   @31     RW

    # FMC500 SPI control.  Reads and writes to the three SPI devices on the
    # FMC500M ADC/DAC card.
    FMC_SPI     RW
        # Data to write and returned data
        .DATA       8       RW
        # Register address within selected device
        .ADDRESS    15      W
        # Select device to address:
        #
        # :0: Clock controller, LMK04826B
        # :1: ADC, AD9684
        # :2: DAC, AD9122
        .SELECT     2 @29   W
        # Set to 1 to trigger a read cycle on the selected SPI address, follow
        # up by reading from this register to read the result
        .RW_N       @31     W

    # DAC test data pattern
    DAC_TEST    2 RW

    # Revolution clock IDELAY control
    :IDELAY     REV_IDELAY


# Control registers
# These occupy addresses 0x2000..02x7FF
# Used for shared DSP control
!CTRL
    # Captures single clock pulsed events, resets on read.
    PULSED      R
        # Set if an AXI data error occurs when writing to slow memory.  Should
        # never occur.
        .DRAM1_ERROR

    # Control over central inter-channel multiplexers, and related global
    # settings.  All MUX fields should be set to the same value for normal
    # operation: for independent channels, set all MUX bits to 0, for coupled
    # channels set to 1.
    CONTROL     RW
        # ADC mux: if set input to channel 0 FIR has copy of channel 1 ADC
        .ADC_MUX
        # NCO0 mux: if set channel 0 NCO0 has sin data from channel 1
        .NCO0_MUX
        # NCO1 mux: if set channel 0 NCO1 has sin data from channel 1
        .NCO1_MUX
        # Bank mux: if set channel 0 bank selection is copy of bank selection
        # from channel 1.
        .BANK_MUX
        # If set to 1 the output from the corresponding channel is looped back
        # to the ADC input.  Set to 0 for normal operation.
        .LOOPBACK   2
        # Set to 1 to enable output to DAC on the corresponding channel,
        # otherwise zero is output.
        .OUTPUT     2

    # Control and readout registers for capture to fast memory.
    !MEM
        CONFIG      RW
            # Select pattern of data written to memory according to the table
            # below:
            #
            #   ===== ===== =====
            #   Mux   Ch0   Ch1
            #   ===== ===== =====
            #   0     ADC0  ADC1
            #   1     ADC0  FIR1
            #   2     ADC0  DAC1
            #   3     ADC0  FIR0
            #   4     FIR0  ADC1
            #   5     FIR0  FIR1
            #   6     FIR0  DAC1
            #   7     FIR0  DAC0
            #   8     DAC0  ADC1
            #   9     DAC0  FIR1
            #   10    DAC0  DAC1
            #   11    DAC0  ADC0
            #   12    ADC1  FIR1
            #   13    FIR1  DAC1
            #   14    DAC1  ADC1
            #   15    0     0
            #   ===== ===== =====
            .MUX_SELECT     4
            # Gain selection for FIR capture to DRAM
            .FIR_GAIN       4
            # Individual channel enables.  Do not use, leave as all zeros.
            .ENABLES        2
        COUNT       RW
            # Number of words to capture to memory after STOP event
            .COUNT          28

        *RW
            # Only valid after STOP has been triggered, returns the write
            # address at the time of the trigger event
            ADDRESS     R
            # Write to this register to trigger the select actions
            COMMAND     W
                # Starts capture to memory
                .START
                # Stops capture to memory after specified post trigger capture
                # count has completed.  Has same effect as enabled external
                # trigger event if configured.
                .STOP
                # Resets all error bits
                .RESET

        # Active status bits
        STATUS      R
            # DRAM data capture error bits.  We hope to never see any of these
            # bits set.  The bits correspond to AXI errors as follows:
            #
            #   === ================================================
            #   Bit Error
            #   === ================================================
            #   0   Data error: data overrun while writing
            #   1   Address error: invalid AXI address
            #   2   Data response error: memory write refused
            #   === ================================================
            #
            # None of the above errors should ever occur!
            .ERRORS     3
            # This bit is set if any of the data capture error bits is set.
            .ERROR
            # This bit is set during capture to DRAM
            .ENABLE

    !TRG
        *RW
            PULSED      R
                # Each bit records a raw trigger event from the corresponding
                # trigger source:
                #
                #   ======= ===================================
                #   Bit     Source
                #   ======= ===================================
                #   0       Soft trigger
                #   1       External event trigger
                #   2       Postmortem trigger
                #   3       ADC 0 motion trigger
                #   4       ADC 1 motion trigger
                #   5       State 0 trigger
                #   6       State 1 trigger
                #   ======= ===================================
                .TRIGGERS   7
            # Pulsed trigger control events
            CONTROL     W
                # Start turn clock synchronisation
                .SYNC_TURN
                # Request turn clock sample
                .SAMPLE_TURN
                # Arm sequencer 0 trigger
                .SEQ0_ARM
                # Disarm sequencer 0 trigger
                .SEQ0_DISARM
                # Arm sequencer 1 trigger
                .SEQ1_ARM
                # Disarm sequencer 1 trigger
                .SEQ1_DISARM
                # Arm DRAM0 trigger
                .DRAM0_ARM
                # Disarm DRAM0 trigger
                .DRAM0_DISARM
                # Generate soft trigger event
                .TRIGGER

        # Trigger status readbacks
        STATUS      R
            # Start clock synchronisation busy
            .SYNC_BUSY
            # ADC clock phase after turn synchronisation
            .SYNC_PHASE
            # Synchronisation error detected
            .SYNC_ERROR
            # Waiting for turn clock sample
            .SAMPLE_BUSY
            # ADC clock phase after sample
            .SAMPLE_PHASE
            # Sequencer 0 trigger armed
            .SEQ0_ARMED
            # Sequencer 1 trigger armed
            .SEQ1_ARMED
            # DRAM0 trigger armed
            .DRAM0_ARMED
            # Turn clock counter captured by sample
            .SAMPLE     10 @16

        # Trigger event sources.
        SOURCES     R
            # Sequencer 0 trigger source mask
            .SEQ0       7
            -
            # Sequencer 1 trigger source mask
            .SEQ1       7
            -
            # DRAM0 trigger source mask
            .DRAM0      7

        !CONFIG
            # Turn clock configuration setup
            TURN        RW
                # Configures the internal revolution clock frequency.  Set to
                # the number of machine bunches-1
                .MAX_BUNCH      10
                # Turn clock offset for channel 0 from sync trigger
                .DSP0_OFFSET    10
                # Turn clock offset for channel 1 from sync trigger
                .DSP1_OFFSET    10

            # Blanking windows
            BLANKING    RW
                # DSP 0 blanking window (in turns)
                .DSP0           16
                # DSP 1 blanking window (in turns)
                .DSP1           16

            SEQ0        RW
                # Sequencer 0 trigger delay
                .DELAY          24

            SEQ1        RW
                # Sequencer 1 trigger delay
                .DELAY          24

            DRAM0       RW
                # DRAM0 trigger delay
                .DELAY          24

            # Sequencer trigger configuration
            TRIG_SEQ    RW
                # Sequencer 0 trigger enable mask
                .ENABLE0        7
                -
                # Sequencer 0 blanking enable mask
                .BLANKING0      7
                -
                # Sequencer 1 trigger enable mask
                .ENABLE1        7
                -
                # Sequencer 1 blanking enable mask
                .BLANKING1      7

            # DRAM0 trigger configuration
            TRIG_DRAM   RW
                # Trigger enable mask
                .ENABLE         7
                -
                # Blanking enable mask
                .BLANKING       7
                -
                # Turn clock selection
                .TURN_SEL       1
                # Blanking pulse selection mask
                .BLANKING_SEL   2


# DSP registers
# These occupy addresses 0x3000..0x37FF and 0x3800..3FFF
# Used for channel specific DSP control
!DSP
    !MISC
        *RW
            PULSED      R
                # Set if input data exceeds ADC input limit setting
                .ADC_INP_OVF
                # Set if overflow detected during input compensation filter
                .ADC_FIR_OVF
                # Set if any of the ADC min/max/sum accumulators overflow
                .ADC_MMS_OVF
                # Set when ADC min/max/sum motion exceeds configured threshold
                .ADC_DELTA
                # Set when overflow in FIR data detected in DAC output
                .DAC_FIR_OVF
                # Set when DAC outpu multiplexer detects overflow
                .DAC_MUX_OVF
                # Set if any of the DAC min/max/sum accumulators overflow
                .DAC_MMS_OVF
                # Set if overflow detected during output preemphasis filter
                .DAC_OUT_OVF

            # Writing to this register generates a pulse on the selected bits
            STROBE      W
                # Starts block write to ADC and DAC fast FIR taps
                .WRITE
                # Resets ADC min/max event detector to enable further events
                .RESET_DELTA

        # Sets NCO0 frequency
        NCO0_FREQ   RW

    # Input signal processing
    !ADC
        CONFIG       W
            # Input threshold for reporting input overflow
            .THRESHOLD  14
            # Optional 1 clock delay on ADC input.  Probably not useful.
            .DELAY      1
            # Limit threshold for min/max/sum bunch motion event detector
            .DELTA      16
        # After triggering write start, input compensation taps are written to
        # this register in sequence.
        TAPS
        # Bunch by bunch motion for ADC input data, after compensation filter
        :MMS

    # Shared bunch by bunch configuration
    !BUNCH
        CONFIG      W
            # Determines bunch bank to be written, resets write pointer
            .BANK       2
        # Repeated writes to this register update the configuration for
        # successive bunches
        BANK        W

    # Bunch by bunch filter
    !FIR
        CONFIG      RW
            # Configures which group of taps will be written when writing to the
            # TAPS register.
            .BANK       2
            # Determines decimation count: set this to target decimation count
            # less 1.
            .LIMIT      7
            # Scaling factor for decimated data, needs to be set up correctly to
            # avoid silent overflow.
            .SHIFT      3
        # Writing to this register programs the FIR taps for the selected bank.
        # The tap write counter is reset by any write to the config register.
        TAPS        W

    !DAC
        # Output to DAC configuration control
        CONFIG      W
            # Output delay for final DAC output
            .DELAY          10
            # Gain for FIR output
            .FIR_GAIN       5
            # Gain for NCO0 output (NCO1 gain is under sequencer control)
            .NCO0_GAIN      4
            # Global control for FIR enable
            .FIR_ENABLE
            # Global control for NCO0 enable
            .NCO0_ENABLE
            # Global control for NCO1 enable
            .NCO1_ENABLE
        # After triggering write start, input compensation taps are written to
        # this register in sequence.
        TAPS
        # Bunch by bunch motion for DAC input data, before pre-emphasis filter
        :MMS

    # Sequencer control
    !SEQ
        *RW
            STATUS      R
                # Current sequencer state
                .PC         3
                # Set if sequencer busy
                .BUSY
                # Current super sequencer counter
                .SUPER      10
            COMMAND     W
                # Interrupts sequencer if running and resets to state 0
                .ABORT
                # Initiates write to selected memory block
                .WRITE

        CONFIG      RW
            # Starting sequencer program counter when triggered
            .PC             3
            # Sequencer state to generate trigger event
            .TRIGGER        3
            # Starting super sequencer counter when triggered
            .SUPER_COUNT    10
            # Identifies which memory block is written when writing to the WRITE
            # register:
            #
            #   ======= ====================================
            #   Value   Target
            #   ======= ====================================
            #   0       sequencer program memory
            #   1       detector window memory
            #   2       super sequencer memory
            #   ======= ====================================
            .TARGET         2
        # Writing to this register updates the selected internal sequencer
        # memory bank.
        WRITE

    # Detector control
    !DET
        # Configures global behaviour of the four detectors
        CONFIG      RW
            # Select FIR gain: 0 selects low order bits from FIR, 1 selects
            # high order bits
            .FIR_GAIN   1
            # Select data input source: 0 selects ADC data, 1 selects scaled
            # FIR data
            .SELECT
            -           6
            # Output scaling for detector 0
            .SCALE0     3
            # Output enable for detector 0
            .ENABLE0
            # Output scaling for detector 1
            .SCALE1     3
            # Output enable for detector 1
            .ENABLE1
            # Output scaling for detector 2
            .SCALE2     3
            # Output enable for detector 2
            .ENABLE2
            # Output scaling for detector 3
            .SCALE3     3
            # Output enable for detector 3
            .ENABLE3
            # Select which bunch bank is written to when writing to the detector
            # bunch register
            .BANK       2 @30
        *RW
            # Captures events generated by the detector, reset on readout
            EVENTS      R
                # For each detector, set if output overflow was detected when
                # transmitting detector result
                .OUTPUT_OVFL    4
                # For each detector, set if data was lost.  This can happen if
                # detector data is written to rapidly
                .UNDERRUN       4
                # For each detector, set if FIR overflow was detected on data
                # used in the detector.
                .FIR_OVFL       4
            COMMAND     W
                # Triggers start of write to detector bunch enable memory.
                .WRITE
                # Resets output address for detector capture
                .RESET
        # Writing to this register programs the bunch enable memory for the
        # detector selected by writing to the CONFIG BANK selection.  First
        # reset the address by setting COMMAND RESET and then write 32 enable
        # bits at a time until all bunches have been programmed.
        BUNCH       W
