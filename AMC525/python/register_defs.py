#!/usr/bin/env python

import sys
import parse_indent


head_template = '''\
--
-- DO NOT EDIT THIS FILE !!!
--
-- This file has been automatically generated.
-- To change this file edit the source file and rebuild.
--

-- Register definitions

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

package %s is
'''
tail_template = 'end;'
reg_template   = '    constant %s : natural := %d;'
range_template = '    subtype %s is natural range %d to %d;'


# A register definition may be followed by a count, in which case this will
# define a range rather than a single register.
def parse_register_count(line):
    parse = line.split()
    if len(parse) == 1:
        return parse[0], 1
    else:
        return parse[0], int(parse[1])


def prefix_name(prefix, name, suffix):
    return '%s%s_%s' % ('_'.join(prefix + ['']), name, suffix)


# Emits a range of register values
def emit_range(prefix, name, index, count):
    suffix = 'REGS' if prefix else 'REGS_RANGE'
    reg_name = prefix_name(prefix, name, suffix)
    print range_template % (reg_name, index, index + count - 1)


def emit_register_name(prefix, name, index, suffix):
    reg_name = prefix_name(prefix, name, suffix)
    print reg_template % (reg_name, index)


# Emits a single register definition, or a R/W pair of definitions if the
# register definition consists of two names.
def emit_register(prefix, name, index):
    parse = name.split('/')
    if len(parse) > 1:
        emit_register_name(prefix, parse[0], index, 'REG_W')
        emit_register_name(prefix, parse[1], index, 'REG_R')
    else:
        emit_register_name(prefix, name, index, 'REG')


# Generates the definitions for a single group of registers, returns the number
# of registers in that group.
def generate_defs(prefix, index, top_name, defs):
    if defs:
        count = 0
        for name, more_defs in defs:
            count += generate_defs(
                prefix + [top_name], index + count, name, more_defs)
        emit_range(prefix, top_name, index, count)
        return count
    else:
        reg_name, count = parse_register_count(top_name)
        if count > 1:
            emit_range(prefix, reg_name, index, count)
        else:
            emit_register(prefix, reg_name, index)
        return count


# Generates complete entity definition
def generate_entity(entity, input):
    print head_template % entity
    for group_name, group_body in input:
        print '    -- Definitions for %s' % group_name
        generate_defs([], 0, group_name, group_body)
        print
    print tail_template


if __name__ == '__main__':
    entity = sys.argv[2] if len(sys.argv) > 2 else 'register_defs'
    input = parse_indent.parse_indented_file(sys.argv[1])
    generate_entity(entity, input)
